###################
install.package("package_name")####insatall a package.
install.package(c(" ", " ", " ")) ###install multiple packages.
library(package_name)
rm(list = ls(all = TRUE)) ## Clear workspace

###################reading data in the format of .csv
read.csv("C:\\Users\\qwu01\\Desktop\\Statistics\\Bayesian data analysis\\dataoftumorcontrol.csv", header=FALSE)

##################plot two histgram in one plot with different colors
a=rnorm(1000, 3, 1)
b=rnorm(1000, 6, 1)
hist(a, xlim=c(0,10), col="red")
hist(b, add=T, col=rgb(0, 1, 0, 0.5) )
t <- hist(a, xlim=c(0,10), col="red")

##################display outputs of hist function
histrv<-hist(x)
histrv$breaks
histrv$density

##################how to plot several ines in one figure
###first use plot and then use line to add lines in the same figure
###here Orange$Tree etc are datas set by system
# Create Line Chart

# convert factor to numeric for convenience 
Orange$Tree <- as.numeric(Orange$Tree) 
ntrees <- max(Orange$Tree)

# get the range for the x and y axis 
xrange <- range(Orange$age) 
yrange <- range(Orange$circumference) 

# set up the plot 
plot(xrange, yrange, type="n", xlab="Age (days)",
  	ylab="Circumference (mm)" ) 
colors <- rainbow(ntrees) 
linetype <- c(1:ntrees) 
plotchar <- seq(18,18+ntrees,1)

# add lines 
for (i in 1:ntrees) { 
  tree <- subset(Orange, Tree==i) 
  lines(tree$age, tree$circumference, type="b", lwd=1.5,
    lty=linetype[i], col=colors[i], pch=plotchar[i]) 
} 

# add a title and subtitle 
title("Tree Growth", "example of line plot")

# add a legend 
legend(xrange[1], yrange[2], 1:ntrees, cex=0.8, col=colors,
  	pch=plotchar, lty=linetype, title="Tree")


######display different plots in one figure
par(mfrow=c(2,3))
###for example
# 4 figures arranged in 2 rows and 2 columns
attach(mtcars)
par(mfrow=c(2,2))
plot(wt,mpg, main="Scatterplot of wt vs. mpg")
plot(wt,disp, main="Scatterplot of wt vs disp")
hist(wt, main="Histogram of wt")
boxplot(wt, main="Boxplot of wt")
#### or 
layout()
###for example
# One figure in row 1 and two figures in row 2
attach(mtcars)
layout(matrix(c(1,1,2,3), 2, 2, byrow = TRUE))
hist(wt)
hist(mpg)
hist(disp)


######create a zero matrix
array(0, dim = c(2, 2))

######class()
######as.data_type()# change data type forcely

######Removing NA Variables
e.g.
x <- c(1, 2, NA, 4, NA, 5)
bad <- is.na(x)
x(!bad)

######
Option + Command + L to clear the R console
######
element-wise multiplication x * y
matrix multiplication x %*% y

######
head( , )
tail( , )

#####
set.seed(1)

############################## norm curve over a histogram
g = iqf_lowlead_data
h <- hist(g, breaks = c(49.5, 69.5, 89.5, 109.5, 129.5, 149.5), xlim = c(49.5, 149.5), ylim = c(0, 40),
         main = "Norm Curve over Histogram", xlab =  "Full IQ Score for Low Lead group", col = "Red")
xfit<-seq(min(g),max(g),length=40) 
yfit<-dnorm(xfit,mean=mean(g),sd=sd(g)) 
yfit <- yfit*diff(h$mids[1:2])*length(g) 
lines(xfit, yfit, col="black", lwd=2)

######################################################
rowSums(x, dims = )
### x is an array, dim = 1 means row, then take sum for each row with callaping 
other dimensions. dim = 2, means column, then take sum over each row and colum with 
callaping other dimensions. this means, at this situation, the dimesions should 
be greater than 2
####
gl( n, k):generates factor levels, n means level number and k means 
replication of each level
interaction(f1, f2)##f1, f2 are factors generated by gl()
####
split(x, factor)##split R object base on factor
split(x, list(f1, f2))## call interaction automatically
####
with(mtcars, tapply(mpg, cyl, mean))## mtcars is data frame
####
system.time()
Rprof()## example to use Rprof function
############ to evaluate the time consuming of function funloop
######read the funloop function
funLoop = function(x) {
# Initialize res with x
 res = x
 n = nrow(x)
 k = 1

 for (i in 1:n) {
    if (!any(is.na(x[i,]))) {
       res[k, ] = x[i,]
       k = k + 1
    }
 }
 res[1:(k-1), ]
}
######then
#Make up large test case
 xx = matrix(rnorm(2000000),100000,20)
 xx[xx>2] = NA
 x = as.data.frame(xx)
####### Call the R code profiler and give it an output file to hold results
  Rprof("exampleAgg.out")
###### Call the function to be profiled
  y = funAgg(xx)
######Set to NULL or "" to disable profiling
  Rprof(NULL)
######check the report
  summaryRprof("exampleAgg.out")


#########
How to Remove Duplicate Data in R:
#########
> duplicated(c(1,2,1,3,1,4))
[1] FALSE FALSE TRUE FALSE TRUE FALSE
If you try this on a data frame, R automatically checks the observations (meaning, it treats every row as a value). So, for example, with the data frame iris:

> duplicated(iris)
 [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [10] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
....
 [136] FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE
[145] FALSE FALSE FALSE FALSE FALSE FALSE
If you look carefully, you notice that row 143 is a duplicate (because the 143rd element of your result has the value TRUE). You also can tell this by using the which() function:

> which(duplicated(iris))
[1] 143
Now, to remove the duplicate from iris, you need to exclude this row from your data. Remember that there are two ways to exclude data using subsetting:

Specify a logical vector, where FALSE means that the element will be excluded. The ! (exclamation point) operator is a logical negation. This means that it converts TRUE into FALSE and vice versa. So, to remove the duplicates from iris, you do the following:

> iris[!duplicated(iris), ]
Specify negative values. In other words:

> index <- which(duplicated(iris))
> iris[-index, ]
##################
order() and rank()
rank returns a vector with the "rank" of each value. 
the number in the first position is the 9th lowest. 
order returns the indices that would put the initial vector x in order.

##################
create an empty list
##################
mylist <- as.list(rep(NA, #))##check or coerce to create a # level list with names NA
mylist <- list()
##################
create an empty data frame
##################
mydataframe <- as.data.frame()
mydataframe <- data.frame()



